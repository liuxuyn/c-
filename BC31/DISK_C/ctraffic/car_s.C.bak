#include <math.h>
#include <stdio.h>
#include <graphics.h>
#include "all.h"
#include "car_s.h"


/*处理前方报警的函数(共用)*/
void do_alarm(struct CAR *p)
{
    if(p->alarm==1)//如果在最短距离内，有警报
    {
        p->speed=0;//停车
    }
    else if(p->alarm==2)//如果在中距内
    {
		p->speed=1*RATE;   //置为慢速
	}
	else if(p->alarm==0)//没有警报
	{
		p->speed=p->std_speed;//置为初始化的速度
	}
}

//转弯前的直道扫描函数（共用）
void pre_scan(struct CAR pa[],int n,struct CAR *p)
{
    //pa指向整个数组的首地址，p则指向当前的车辆
    int i;
    for(i=0;i<n;i++,pa++)
    {
         if(pa->justment==p->justment)  //&&(pa->flag==p->flag))//???????
         {
	      switch(p->justment)
             {
 	         //如果警戒范围内有车，则警报置为1
	        case 10:
	        case 11:
	        case 12:
			if( (pa->x < p->x)&&((pa->x+DIS) > p->x) )
			    p->alarm=1;
						else if(  ((pa->x+DIS) < p->x)&&((pa->x+DIL) >p->x  ))
                            p->alarm=2;
			else if( (pa->x+DIL) < p->x )             //&&((pa->x+3*DIS) > p->x ))
                            p->alarm=0;//将距离梯度化，在最短距离内停车，中距内慢速行驶，长距内以初始化速度行驶
			break;

	        case 20:
	        case 21:	
	        case 22:
			if( (pa->y < p->y)&&((pa->y+DIS) > p->y) )
			    p->alarm=1;
						else if( ((pa->y+DIS) < p->y )&&((pa->y+DIL) >p->y  ))
                            p->alarm=2;
			else if( (pa->y+DIL) < p->y )    //&&((pa->y+3*DIS) > p->y ))
                            p->alarm=0;
			break;

	        case 30:
	        case 31:	
	        case 32:
			if(  (pa->x > p->x) && ( (pa->x-DIS) < p->x ) )
			    p->alarm=1;
                        else if(  ((pa->x-DIS) > p->x) && ((pa->x-DIL) < p->x) )
                            p->alarm=2;
			else if(  (pa->x-DIL) > p->x)     //&&((pa->x-3*DIS) < p->x ))
                            p->alarm=0;
			break;

	        case 40:
	        case 41:	
	        case 42:
			if( (pa->y > p->y) &&((pa->y-DIS)< p->y) )
			    p->alarm=1;
                        else if( ((pa->y-DIS) > p->y)&&((pa->y-DIL) < p->y  ))
                            p->alarm=2;
			else if( (pa->y-DIL) > p->y)         //&&((pa->y-3*DIS) < p->y ))
                            p->alarm=0;
			break;
             }
         }
     }
}

//转弯后的直道扫描函数（共用）

void ex_scan(struct CAR *pa,int n,struct CAR *p)
{
    //pa指向整个数组的首地址，p则指向当前的车辆
    //int d=ALARMDIS*5/4;//d为警戒距离
    int i;
    for(i=0;i<n;i++,pa++)
    {
         if(pa->justment==p->justment)               //&&(pa->flag==p->flag))
         {
	      switch(p->justment)
             {
 	         //如果警戒范围内有车，则警报置为1
                 //转到北路的车
	        case 10:
	        case 21:
	        case 32:
			if( (pa->y < p->y) &&((pa->y+DIS)>= p->y) )
			    p->alarm=1;
                        else if( ((pa->y+DIS) < p->y)&&( (pa->y+DIL) >= p->y  ))
                            p->alarm=2;
			else if( (pa->y+DIL) < p->y)        
                            p->alarm=0;
			break;
            
                //转到西路的车
	        case 11:
	        case 22:	
	        case 40:
			if(  (pa->x < p->x) && ( (pa->x+DIS) >= p->x ) )
			    p->alarm=1;
                        else if(  ((pa->x+DIS) < p->x) && ((pa->x+DIL) >= p->x) )
                            p->alarm=2;
			else if(  (pa->x+DIL) < p->x)     
                            p->alarm=0;
			break;

                //转到南路的车
	        case 12:
	        case 30:	
	        case 41:
			if( (pa->y > p->y)&&((pa->y-DIS) <= p->y) )
			    p->alarm=1;
						else if( ((pa->y-DIS) > p->y )&&((pa->y-DIL) <=p->y  ))
                            p->alarm=2;
			else if( (pa->y-DIL) > p->y )   
                            p->alarm=0;
			break;

                //转到东路的车
	        case 20:
	        case 31:	
	        case 42:
			if( (pa->x > p->x)&&((pa->x-DIS) <= p->x) )
			    p->alarm=1;
						else if(  ((pa->x-DIS) > p->x)&&((pa->x-DIL) <= p->x  ))
                            p->alarm=2;
			else if( (pa->x-DIL) > p->x )             
                            p->alarm=0;
			break;
             }
         }
     }
}

/*判断控制直行车辆*/
void do_straight_s(struct CAR *pcar,int n,struct CAR *p,struct LAMP *pl)
{
	int i=0;                  //pcar指向整个数组的首地址，p则指向当前的车辆
	struct CAR *pa=pcar;
	int stopx[2]={BXO-3*RY-RR-D,BXO+3*RY+RR+D};    //西东向停车线
	int stopy[2]={BYO-3*RX-RR-D,BYO+3*RX+RR+D};    //北南向停车线
	int limit_rx[6],limit_ry[6];

	for (i=0;i<6;i++)                             //初始化限定数组
	{
	   limit_rx[i]=BXO-(5*RY/2)+RY*i;
	   limit_ry[i]=BYO-(5*RX/2)+RX*i;
	}

	switch(p->justment)
	{
	 case 11:
			 if((pl+2)->sc==LIGHTGREEN)//绿灯可以通行的情况下
			 {
		  pre_scan(pa,n,p);   //扫描前方路况信息
		  do_alarm(p);        //把车速置为初始化时的车速或者是用于过渡的慢车速，这要根据p->alarm判断
				  p->y=limit_ry[1];   //东道右向应该位于11道
		  p->x -= (p->speed); //步进完成直线行驶，以即时速率大小为步进单位长度
			 }
			 else //if((pl+2)->sc==RED)//红灯的情况下
			 {
				 if((p->x > stopx[1])&&(p->x < (stopx[1]+W)))   //在停车线的邻域内
				 {
					 p->speed=0;
					 p->y=limit_ry[1];          //东道右向应该位于11道
			 p->x -= (p->speed);        //步进完成直线行驶，以即时速率大小为步进单位长度
				 }
				 else                          //过了停车线
				 {
					 pre_scan(pa,n,p);
					 do_alarm(p);
					 p->y=limit_ry[1];
			 p->x -= (p->speed);
			    }
			 }

			  break;

	 case 21:
			 if((pl+3)->sc==LIGHTGREEN)     //绿灯可以通行的情况下
			 {
		  pre_scan(pa,n,p);
		  do_alarm(p);
				  p->x=limit_rx[4];
		  p->y -= (p->speed);
			 }
			 else //if((pl+3)->sc==RED)           //红灯的情况下
			 {
				 if((p->y > stopy[1])&&(p->y < (stopy[1]+W)))
				 {
					 p->speed=0;
					 p->x=limit_rx[4];
			 p->y -= (p->speed);
				 }
				 else
				 {
					 pre_scan(pa,n,p);
					 do_alarm(p);
					 p->x=limit_rx[4];
			 p->y -= (p->speed);
			 }
			 }
			  break;

	 case 31:
			 if(pl->sc==LIGHTGREEN)//绿灯可以通行的情况下
			 {

		  pre_scan(pa,n,p);
		  do_alarm(p);
				  p->y=limit_ry[4];
		  p->x += (p->speed);
			 }
			 else //if(pl->sc==RED)//红灯的情况下
			 {
				 if((p->x < stopx[0])&&(p->x > (stopx[0]-W)))
				 {
					 p->speed=0;
					 p->y=limit_ry[4];
			 p->x += (p->speed);
				 }
				 else                     //过了停车线
				 {
					 pre_scan(pa,n,p);
					 do_alarm(p);
					 p->y=limit_ry[4];
			 p->x += (p->speed);
			 }
			 }
			  break;

	 case 41:
			 if((pl+1)->sc==LIGHTGREEN)
			 {
		  pre_scan(pa,n,p);
		  do_alarm(p);
				  p->x=limit_rx[1];
		  p->y += (p->speed);
			  }
			 else              //红灯的情况下
			 {
				 if((p->y < stopy[0])&&(p->y > (stopy[0]-W)))
				 {
					 p->speed=0;
					 p->x=limit_rx[1];
			 p->y += (p->speed);
				 }
				 else                //过了停车线
				 {
					 pre_scan(pa,n,p);
					 do_alarm(p);
					 p->x=limit_rx[1];
			 p->y += (p->speed);
			 }
			 }
                      
              break;
    }   
}

/*执行车辆转弯的函数*/
void do_turn_s(struct CAR *p)
{
    //stdx,stdy为转弯的圆心，r1,r2为公转半径
    int i=p->count,sp=p->speed,r1=RR+RY/2+D,r2=RR+7*RY/2+D;  //大小公转半径
    int stdx[2]={BXO-3*RY-RR-D,BXO+3*RY+RR+D};          //圆心坐标的大小x
    int stdy[2]={BYO-3*RX-RR-D,BYO+3*RX+RR+D};          //圆心坐标的大小y
    double t=P/180;

    if((i*t*sp)<P/2)     //count为转过一个弯所需的步数，由1开始累加，sp为一步走的像素数
    { 
       p->count++;          
       i=p->count;
       switch(p->justment)
       {
        case 10:
 	        p->x=stdx[1]-r1*sin(i*t*sp);
	        p->y=stdy[0]+r1*cos(i*t*sp);
                p->angle -=sp*t;           //p->angle=P/2-i*t*sp;
	        break;
        case 12:
 	        p->x=stdx[1]-r2*sin(i*t*sp);
	        p->y=stdy[1]-r2*cos(i*t*sp);
                p->angle +=sp*t;
	        break;

        case 20:
 	        p->x=stdx[1]-r1*cos(i*t*sp);
	        p->y=stdy[1]-r1*sin(i*t*sp);
                p->angle -=sp*t;
	        break;
        case 22:
 	        p->x=stdx[0]+r2*cos(i*t*sp);
	        p->y=stdy[1]-r2*sin(i*t*sp);
                p->angle +=sp*t;
	        break;

        case 30:
 	        p->x=stdx[0]+r1*sin(i*t*sp);
	        p->y=stdy[1]-r1*cos(i*t*sp);
                p->angle -=sp*t;
	        break;
        case 32:
 	        p->x=stdx[0]+r2*sin(i*t*sp);
	        p->y=stdy[0]+r2*cos(i*t*sp);
                p->angle +=sp*t;
	        break;

        case 40:
 	        p->x=stdx[0]+r1*cos(i*t*sp);
	        p->y=stdy[0]+r1*sin(i*t*sp);
                p->angle -=sp*t;
	        break;
        case 42:
 	        p->x=stdx[1]-r2*cos(i*t*sp);
	        p->y=stdy[0]+r2*sin(i*t*sp);
                p->angle +=sp*t;
	        break;
        }
    }
}

/*控制要左转的车辆*/
void do_left_s(struct CAR *pcar,int n,struct CAR *p,struct LAMP *pl)
{                        //pcar指向整个数组的首地址，p则指向当前的车辆
	struct CAR *pa=pcar;
	int i=0;
  int stopx[2]={BXO-3*RY-RR-D,BXO+3*RY+RR+D};
	int stopy[2]={BYO-3*RX-RR-D,BYO+3*RX+RR+D};//用于停车判断交通灯的停车线
	int limit_rx[6],limit_ry[6];
    for (i=0;i<6;i++)//初始化限定数组
    {
       limit_rx[i]=BXO-(5*RY/2)+RY*i;
       limit_ry[i]=BYO-(5*RX/2)+RX*i;
    }

    switch(p->justment)
    {
    case 12:
	    if((pl+2)->lc==LIGHTGREEN)//左转灯是绿灯，可以通行
            {    
                if(p->x > stopx[1])
		    {
		         pre_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[2];
		         p->x -= (p->speed);
                     }
                else if((p->x <=stopx[1])&&(p->y<stopy[1]))      
                     {
                          p->speed=1*RATE;
                          do_turn_s(p);
                     }
                else if(p->y>=stopy[1])
                      {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[2];
		         p->y += (p->speed);
		         p->angle=P;
                      }
             }

			 else 
             {
                 if((p->x >= stopx[1])&&(p->x < (stopx[1]+W)))//在停车线的邻域内
                     {
                         p->speed=0;
                         p->y=limit_ry[2];
		         p->x -= (p->speed);
                     }
                 else if(p->x >=( stopx[1]+W))//在停车线邻域之外(未过停车线)
                     {
                         pre_scan(pa,n,p);//扫描前方路况信息
                         do_alarm(p);
                         p->y=limit_ry[2];
		         p->x -= (p->speed);
                     }
                 else if((p->x < stopx[1])&&(p->y < stopy[1]))//过了停车线
                    {
                         p->speed=1*RATE;
                         do_turn_s(p);
                    }
                 else if(p->y >= stopy[1])//转弯后
                     {
		                     ex_scan(pa,n,p);//转弯后扫描前方路况信息
			                   do_alarm(p);
                         p->x=limit_rx[2];
		         p->y += (p->speed);
		         p->angle=-P;
                      }
             }
             break;

    case 22:
	    if((pl+3)->lc==LIGHTGREEN)//左转灯是绿灯，可以通行
            {    
				if(p->y > stopy[1])
		    {
		         pre_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[3];
		         p->y -= (p->speed);
                    }
                else if((p->y <=stopy[1])&&(p->x>stopx[0]))      
                      {
                          p->speed=1*RATE;
                          do_turn_s(p);
                       }
                else if(p->x<=stopx[0])
                      {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[2];
		         p->x -= (p->speed);
		         p->angle=P/2;
                      }
             }

			 else 
             {
                 if(p->y >= stopy[1]&&(p->y<stopy[1]+W))//在停车线的邻域内
                     {
                         p->speed=0;
                         p->x=limit_rx[3];
		         p->y -= (p->speed);                
                     }
                 else if(p->y >= stopy[1]+W)      // (未过停车线)
                     {
                         pre_scan(pa,n,p);       //扫描前方路况信息
                         do_alarm(p);
                         p->x=limit_rx[3];
		         p->y -= (p->speed);
                     }
                 else if((p->y < stopy[1])&&(p->x > stopx[0]))//过了停车线
                     {
                         p->speed=1*RATE;
                         do_turn_s(p);
                     }
                 else if(p->x <= stopx[0])//转弯后
                     {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[2];
		         p->x -= (p->speed);
		         p->angle=P/2;
                      }
             }
             break;

    case 32:
	    if(pl->lc==LIGHTGREEN)//左转灯是绿灯，可以通行
            {    
				if(p->x < stopx[0])
		     {
		         pre_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[3];
		         p->x += (p->speed);
                      }
                else if((p->x >=stopx[0])&&(p->y>stopy[0]))      
                      {
                          p->speed=1*RATE;
                          do_turn_s(p);
                       }
                else if(p->y<=stopy[0])                         
                      {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[3];
		         p->y -= (p->speed);
		         p->angle=0;
                      }
             }

			 else 
             {
                 if((p->x <= stopx[0])&&(p->x > (stopx[0]-W)))           //在停车线的邻域内
                     {
                         p->speed=0;
                         p->y=limit_ry[3];
		         p->x += (p->speed);                         
                     }
                 else if(p->x <= stopx[0]-W)              //未过停车线
                     {
                         pre_scan(pa,n,p);               //扫描前方路况信息
                         do_alarm(p);
                         p->y=limit_ry[3];
		         p->x += (p->speed);
                     }
                 else if((p->x > stopx[0])&&(p->y > stopy[0]))//过了停车线
                    {
                         p->speed=1*RATE;
                         do_turn_s(p);
                    }
                 else if(p->y <= stopy[0])                                 //转弯后
                     {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[3];
		         p->y -= (p->speed);
		         p->angle=0;
                      }
             }
             break;

    case 42:
	    if((pl+1)->lc==LIGHTGREEN)//左转灯是绿灯，可以通行
            {    
                 if((p->y <= stopy[0])&&(p->y > (stopy[0]-W)))//在停车线的邻域内
                     {
                         pre_scan(pa,n,p);
                         do_alarm(p);
                         p->x=limit_rx[2];
                         p->y += (p->speed);    
                     }
                 else if((p->y <= stopy[0]-W))              //在停车线邻域之外(未过停车线)
                     {
                         pre_scan(pa,n,p);//扫描前方路况信息
                         do_alarm(p);
                         p->x=limit_rx[2];
                         p->y += (p->speed);                            
                     }
                 else if((p->y > stopy[0])&&(p->x < stopx[1]))       //过了停车线
                     {
                         p->speed=1*RATE;
                         do_turn_s(p);
                     }
                 else if(p->x >= stopx[1])                       //转弯后
                     {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[3];
		         p->x += (p->speed);
		         p->angle=-P/2;
                      }
             }

			 else 
			 {
				 if((p->y <= stopy[0])&&(p->y > (stopy[0]-W)))//在停车线的邻域内
					 {
						 p->speed=0;
						 p->x=limit_rx[2];
						 p->y += (p->speed);
					 }
				 else if((p->y <= stopy[0]-W))            //在停车线邻域之外(未过停车线)
					 {
						 pre_scan(pa,n,p);              //扫描前方路况信息
						 do_alarm(p);
						 p->x=limit_rx[2];
						 p->y += (p->speed);
					 }
				 else if((p->y > stopy[0])&&(p->x < stopx[1]))       //过了停车线
					 {
						 p->speed=1*RATE;
						 do_turn_s(p);
					 }
				 else if(p->x >= stopx[1])                       //转弯后
					 {
				 ex_scan(pa,n,p);
			 do_alarm(p);
						 p->y=limit_ry[3];
				 p->x += (p->speed);
				 p->angle=-P/2;
					  }
			 }
			 break;

    }
}

/*控制要右转的车辆*/
void do_right_s(struct CAR *pcar,int n,struct CAR *p,struct LAMP *pl)
{
    //pcar指向整个数组的首地址，p则指向当前的车辆
	struct CAR *pa=pcar;
	int i;
    int stopx[2]={BXO-3*RY-RR-D,BXO+3*RY+RR+D};
	int stopy[2]={BYO-3*RX-RR-D,BYO+3*RX+RR+D};//用于停车判断交通灯的停车线
	int limit_rx[6],limit_ry[6];
	for (i=0;i<6;i++)//初始化限定数组
	{
	   limit_rx[i]=BXO-(5*RY/2)+RY*i;
	   limit_ry[i]=BYO-(5*RX/2)+RX*i;
	}
	//int w=5//，d1用于调整东西方向慢速车加速行驶的距离，d2用于调整南北方向慢速车加速行驶的距离
	switch(p->justment)
	{
			
	case 10:
		if((pl+2)->rc==LIGHTGREEN)//右转灯是绿灯，可以通行
            {
				if( p->x > stopx[1] )
		    {
		         pre_scan(pa,n,p);//扫描前方路况信息
                         do_alarm(p);        
                         p->y=limit_ry[0];
		         p->x -= (p->speed);
                     }
                else if((p->x <=stopx[1])&&(p->y>stopy[0]))      
                      {
                          p->speed=1*RATE;               //转弯均为慢速
                          do_turn_s(p);
                       }
                else if(p->y<=stopy[0])
                      {
		         ex_scan(pa,n,p);//转弯后扫描前方路况信息
                         do_alarm(p);//停车，防止追尾
                         p->x=limit_rx[5];
		         p->y -= (p->speed);
		         p->angle=0;
                      }
             }
             break;                         
      
    case 20:
		if((pl+3)->rc==LIGHTGREEN)//右转灯是绿灯，可以通行
            {
                if(p->y > stopy[1])
		    {
		         pre_scan(pa,n,p);//扫描前方路况信息
                         do_alarm(p);//停车，防止追尾
                         p->x=limit_rx[5];
		         p->y -= (p->speed);
                    }
                else if((p->y <=stopy[1])&&(p->x <stopx[1]))      
                    {
                          p->speed=1*RATE;
                          do_turn_s(p);
                     }
                else if(p->x>=stopx[1])
                    {
		         ex_scan(pa,n,p);//扫描前方路况信息
                         do_alarm(p);//停车，防止追尾  
                         p->y=limit_ry[5];
		         p->x += (p->speed);
		         p->angle=3*P/2;
                    }
             }
             break;

    case 30:
	    if(pl->rc==LIGHTGREEN)//右转灯是绿灯，可以通行
            {
				if(p->x < stopx[0])
		    {
		         pre_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[5];
		         p->x += (p->speed);
                      }
                else if((p->x >=stopx[0])&&(p->y<stopy[1]))      
                      {
                          p->speed=1*RATE;
                          do_turn_s(p);
                       }
                else if(p->y>=stopy[1])
                      {
		         ex_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[0];
		         p->y += (p->speed);
		         p->angle=P;
                      }
             }
             break;

    case 40:
		if((pl+1)->rc==LIGHTGREEN)//右转灯是绿灯，可以通行
			{
				if(p->y < stopy[0])
		     {
		         pre_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->x=limit_rx[0];
		         p->y += (p->speed);
                      }
                else if((p->y >=stopy[0])&&(p->x>stopx[0]))      
                      {
                          p->speed=1*RATE;
                          do_turn_s(p);
                       }
                else if(p->x<=stopx[0])
                      {
		         ex_scan(pa,n,p);//扫描前方路况信息
			 do_alarm(p);
                         p->y=limit_ry[0];
		         p->x -= (p->speed);
		         p->angle=P/2;
                      }
             }
             break;
    }
}

/*控制单个车辆运行的函数*/
void control_single_car_s(struct CAR *pp,int n,struct CAR *p,struct LAMP *pl)
{                       //pp指向整个数组的首地址，p则指向当前的车辆
  if((p->justment==11)||(p->justment==21)||(p->justment==31)||(p->justment==41))       //1表示直行车道
       do_straight_s(pp,n,p,pl); //控制直行车辆

  else if((p->justment==10)||(p->justment==20)||(p->justment==30)||(p->justment==40))  //0标志右转车道
	     do_right_s(pp,n,p,pl);    //控制要右转的车辆

  else  if((p->justment==12)||(p->justment==22)||(p->justment==32)||(p->justment==42))  //其余即2为左转车道
	   do_left_s(pp,n,p,pl);     //控制要左转的车辆
}

/*控制全部车辆运行的函数*/
void control_car_s(struct CAR *p,struct LAMP *pl,int n)
{
	int i;
	struct CAR *pc=NULL;
	pc=p;
	for(i=0;i<n;i++)
	{
		 control_single_car_s(pc,n,p,pl);
		 p++;
	}
}

